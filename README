Nathan MVC Framework!

Welcome to what is probably one of the most basic PHP MVC frameworks you'll find.

The idea of Nathan MVC (I honestly couldn't think of a better name) is for PHP developers not necessarily versed on the basics of the Model View Controller pattern to have a framework clean of clutter and unnecessary addons, so they can focus on exploring the fundamentals of the pattern while having a working example from the very first step.

Nathan MVC comes with a .htaccess file built to allow /controller/action/id style URL requests, error and home controller and model classes which act as examples, and a basic main template file. There are also four classes and index.php, which form the underlying structure of the framework.

This framework is based on a series of articles I wrote for my portfolio website www.nathandavison.com.

------------
Installation
------------

Simply copy this project to a working Apache web server with PHP. It may work on other web servers, but the /controller/action URL rewriting will only work on Apache out-of-the-box.

Tested versions include Apache 2.2.3 and PHP 5.3.6.

------------
Tips
------------

- Check out how HomeController and ErrorController are coded to understand how this framework works.
- All controllers should be contained in the controller directory, and share the same filename as the controller used in the URL, with a PHP extension. The actual class name of a controller should be XxxController e.g. HomeController, ErrorController, etc.
- All controllers must extend from the BaseController class.
- All directories under /views should share the name of the controller, with an upper case first letter, and minus the 'Controller' part, e.g. Home, Error, etc (upper case first letter is important on Linux).
- If you want any view to be shown without using a main template, append /ajax to the URL (i.e. /home/index/ajax, /article/view/1/ajax etc). This is built so views can be used by Javascript in ajax calls without hassle.
- Alternatively, if you pass a boolean false as the second argument in the returnView() method of your controller actions (where the first argument is your view data), this view will always be shown without a template.
- If you define a string as returnView()'s second argument instead, it will look for that string as /views/stringvalue.php for that view's template. "maintemplate" is the default value.
- If you extend a model from BaseModel, it will have access to $this->viewModel, which has a method, add(), that allows you to dynamically add properties to the $this->viewModel object. E.g. $this->viewModel->add('pageTitle', 'Home'); would store the string 'Home' in $this->viewModel->pageTitle; .
- Whatever you pass as the first argument of returnView() is available as $viewModel in templates and views. If you passed in $this->viewModel from above, $viewModel->pageTitle would retrieve the pageTitle value in the template/view.

------------
Where to now
------------

If you intend to expand on this framework, your first step is to probably think about where you'll store images, css files and js files (/content and /js ?), and to modify the maintemplate.php file under /views. From there, you can start creating controllers and models appropriately, making sure to extend from the base classes for each (see the existing home and error controllers and models for examples). Then you'll want to match your controller structure in the views directory, and create a view file for each of your controller's actions/methods (again, home and error can be used as an example).

With this all done, any controller, action and view setup you create should be viewable via /controller/action.

If you want to extend the capability of your models, such as including the ability for them to interact with a database, your best bet would be to establish your extensions in the BaseModel class's construct method. Since any model should extend from this class, they would therefore inherit any functionality you add. Other than a database connection, other examples include functionality for generating, validating, and sanitizing. For instance, you may want to add a method on BaseModel which sanitizes the data in $_GET and call this method in the construct, so all models you create and extend from BaseModel have safe values in $_GET.